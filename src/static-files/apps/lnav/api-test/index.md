---
title: lnav API tester
---

# API Test Harness

The following sections contain interactive elements to demonstrate the
various API endpoints that are available.

### Version

The `/api/version` endpoint returns the version of the lnav server and
related information.

<button id="doVersion">Get Version</button>

<div id="version-result-container">
<pre><code id="version-result" class="language-json"></code></pre>
</div>

### Poll

The `/api/poll` endpoint performs a long-poll that will return when the state
of the TUI has changed. You can click the "Poll" button to perform a poll and
see the result.

<button id="doPoll">Poll</button>

<div id="poll-result-container">
<p>
Last Response Time: <div id="poll-time"></div>
<p>
Last Response:
<pre><code id="poll-result" class="language-json">null</code></pre>
</div>

### Exec

The `/api/exec` endpoint executes an lnav script and returns the result.

<label for="exec-input">Script:</label>
<textarea id="exec-input" rows="10" cols="80">
:echo Hello, World!
</textarea>
<button id="doExec">Execute</button>

<div id="exec-result-container">
<pre id="exec-result"></pre>
</div>

### Markdown Magic

To make it easier to add dynamic content to apps, lnav's Markdown processor
injects some JavaScript to automatically evaluate lnav code blocks.
To enable these features, one of the following classes must be added to the
code block:

* `.eval-and-replace` -- The code block will be evaluated when the page is
  loaded and the result will replace the content of the code block.
  This option can be useful for generating dynamic HTML content.
* `.eval-on-demand` -- The code block will be replaced with a button that
  will execute the code block when clicked.
  The label for the button defaults to "Execute," but can be changed by
  adding a `data-label` attribute to the code block.
  The values of any named `<input>` elements will be assigned to variables
  that can be referenced in the code block.
  The result of executing the code block will be handled in the following
  ways:
    - A string will be shown in a block below the button.  A string can
      be returned by using the `:echo` command.
    - A JSON object with properties that match the names of the `<input>`
      elements will be used to update those elements with new values.
      A JSON object can be returned by executing a SQL statement that returns
      a single row followed by the `:write-jsonline-to -` command.
    - A JSON value will be shown in a block below the button and
      syntax-highlighted.
* `.eval-for-bar-chart` -- The code block will be evaluated when the page is
  loaded and the result will be used to generate a bar chart.  The data
  for the chart should be generated by the `:write-json-cols-to -`
  command.

Attributes are added to a Markdown code block on the line of the
opening fence.  The attributes are surrounded by curly-braces
and have the following forms:

* `.`_class_ - A class name should have a leading dot.  The first
  class listed in the attributes must be the language name.
* `#`_id_ - The ID for the element.
* ... - Other values will be copied verbatim to the HTML code block.

For example, to open an lnav code block and add the `.eval-and-replace`
class, you would write the following:

<pre><code class="language-markdown">``` { .lnav .eval-and-replace }
... lnav script here ...
```</code></pre>

### Examples

**Dynamic HTML Content**:
To generate a message with the name of the user running lnav, like this:

``` { .lnav .eval-and-replace }
:echo <blockquote>Hello, <b>${USER}</b>!</blockquote>
```

You would add the `.eval-and-replace` to the following lnav script:

<pre><code class="language-markdown">``` { .lnav .eval-and-replace }
:echo &lt;blockquote&gt;Hello, &lt;b&gt;${USER}&lt;/b&gt;!&lt;/blockquote&gt;
```</code></pre>

---

**Chart results of a PRQL Query**:
To generate a bar chart that shows the number of log messages for each
message level per-hour, you would add the `.eval-for-bar-chart` class to the
following lnav script:

<pre><code class="language-markdown">``` { .lnav .eval-for-bar-chart }
;from all_logs
stats.hist log_level slice:'1h'
select {
  `Messages Per Hour` = sqlite.strftime '%Y-%m-%d %H:%M' tslice,
  v
}
:write-json-cols-to -
```</code></pre>

The result would look like this:

``` { .lnav .eval-for-bar-chart }
;from all_logs
stats.hist log_level slice:'1h'
select {
  `Messages Per Hour` = sqlite.strftime '%Y-%m-%d %H:%M' tslice,
  v
}
:write-json-cols-to -
```

---

**Perform a Query with User Input**:
To increment an `<input type="number">` element, you would add the
`.eval-on-demand` class to the following lnav script:

<label for="counter-value">Counter Value:</label>
<input type="number" name="counterValue" value="10" />

``` { .lnav .eval-on-demand data-label="Increment" }
;SELECT $counterValue + 1 AS counterValue
:write-jsonlines-to -
```


<script src="lnav-api-test.js"></script>
